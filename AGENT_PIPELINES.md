# Документация пайплайнов TRAE Agent

Этот документ описывает все возможные схемы работы агента (pipelines) - последовательности вызовов промтов, инструментов и обработки данных.

## Содержание

1. [Основной пайплайн решения задач](#1-основной-пайплайн-решения-задач)
2. [Пайплайн выполнения инструментов](#2-пайплайн-выполнения-инструментов)
3. [Пайплайн анализа траектории (LakeView)](#3-пайплайн-анализа-траектории-lakeview)
4. [Пайплайн выбора патчей (Patch Selector)](#4-пайплайн-выбора-патчей-patch-selector)

---

## 1. Основной пайплайн решения задач

**Описание:** Это главный пайплайн работы TRAE Agent для решения GitHub issues. Он включает инициализацию, выполнение шагов с использованием LLM и инструментов, и финализацию результата.

**Входные данные:**
- `task`: Описание задачи
- `project_path`: Путь к проекту
- `issue`: Текст GitHub issue
- `base_commit` (опционально): Базовый коммит для сравнения
- `patch_path` (опционально): Путь для сохранения патча

**Выходные данные:**
- `AgentExecution`: Объект с результатами выполнения
  - `success`: Успешность выполнения
  - `steps`: Список всех шагов
  - `final_result`: Финальный результат
  - `total_tokens`: Использованные токены
  - `execution_time`: Время выполнения

### ASCII диаграмма пайплайна:

```
┌─────────────────────────────────────────────────────────────────┐
│                    ИНИЦИАЛИЗАЦИЯ АГЕНТА                         │
└───────────────────────────┬─────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│  1. Создание начальных сообщений (initial_messages)             │
│     - System Message: TRAE_AGENT_SYSTEM_PROMPT                  │
│     - User Message: [Project root path] + [Problem statement]   │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  2. Инициализация инструментов                                  │
│     - str_replace_based_edit_tool                               │
│     - bash                                                      │
│     - sequentialthinking                                        │
│     - json_edit_tool                                            │
│     - task_done                                                 │
│     - ckg (опционально)                                         │
│     - MCP tools (если настроены)                                │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  3. Начало записи траектории                                    │
│     TrajectoryRecorder.start_recording()                        │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
        ┌───────────────┴───────────────┐
        │   ЦИКЛ ВЫПОЛНЕНИЯ ШАГОВ      │
        │   (до max_steps или success)  │
        └───────────────┬───────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  ШАГ N (повторяется до max_steps)                               │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  4. Состояние: THINKING                                  │  │
│  │     - Обновление CLI консоли                             │  │
│  └────────────────────────┬─────────────────────────────────┘  │
│                           ▼                                     │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  5. Вызов LLM                                            │  │
│  │     LLMClient.chat(messages, model_config, tools)        │  │
│  │                                                          │  │
│  │     Промты в контексте:                                  │  │
│  │     - System: TRAE_AGENT_SYSTEM_PROMPT                   │  │
│  │     - User: Issue description + project path             │  │
│  │     - History: Все предыдущие сообщения и результаты     │  │
│  │     - Tools: Описания всех доступных инструментов        │  │
│  └────────────────────────┬─────────────────────────────────┘  │
│                           ▼                                     │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  6. Получение LLM Response                               │  │
│  │     - content: Текстовый ответ агента                    │  │
│  │     - tool_calls: Список вызовов инструментов (если есть)│  │
│  │     - usage: Информация о токенах                        │  │
│  └────────────────────────┬─────────────────────────────────┘  │
│                           ▼                                     │
│            ┌──────────────┴──────────────┐                      │
│            │  Проверка завершения        │                      │
│            └──────┬──────────────┬───────┘                      │
│                   │              │                              │
│          task_done вызван?    tool_calls?                       │
│                   │              │                              │
│                   ▼              ▼                              │
│  ┌────────────────────┐  ┌────────────────────────────────┐    │
│  │  7a. Завершение    │  │  7b. Состояние: CALLING_TOOL   │    │
│  │  - success = True  │  │     Для каждого tool_call:     │    │
│  │  - final_result    │  │                                │    │
│  │  - ВЫХОД ИЗ ЦИКЛА │  │  ┌──────────────────────────┐  │    │
│  └────────────────────┘  │  │  Tool Executor           │  │    │
│                          │  │  - Парсинг аргументов    │  │    │
│                          │  │  - Валидация параметров  │  │    │
│                          │  │  - Выполнение tool.execute│ │    │
│                          │  └────────┬─────────────────┘  │    │
│                          │           ▼                    │    │
│                          │  ┌──────────────────────────┐  │    │
│                          │  │  Tool Result             │  │    │
│                          │  │  - success: bool         │  │    │
│                          │  │  - result: string        │  │    │
│                          │  │  - error: string|None    │  │    │
│                          │  └────────┬─────────────────┘  │    │
│                          └───────────┼────────────────────┘    │
│                                      ▼                          │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  8. Создание User Message с результатами                 │  │
│  │     messages.append(LLMMessage(                          │  │
│  │         role="user",                                     │  │
│  │         content=tool_result.result,                      │  │
│  │         tool_result=tool_result                          │  │
│  │     ))                                                   │  │
│  └────────────────────────┬─────────────────────────────────┘  │
│                           ▼                                     │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  9. Рефлексия (опционально)                              │  │
│  │     reflect_on_result(tool_results)                      │  │
│  │     - Анализ ошибок выполнения инструментов              │  │
│  └────────────────────────┬─────────────────────────────────┘  │
│                           ▼                                     │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  10. Состояние: COMPLETED                                │  │
│  │      - Запись шага в траекторию                          │  │
│  │      - Обновление CLI консоли                            │  │
│  │      - Добавление шага в execution.steps                 │  │
│  └────────────────────────┬─────────────────────────────────┘  │
│                           │                                     │
└───────────────────────────┼─────────────────────────────────────┘
                            │
        Переход к следующему шагу (N+1)
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│  11. Финализация выполнения                                     │
│      - TrajectoryRecorder.finalize_recording()                  │
│      - Сохранение git diff в patch_path (если указан)           │
│      - Закрытие всех инструментов (bash sessions и т.д.)        │
│      - Cleanup MCP clients                                      │
│      - Остановка Docker (если использовался)                    │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  12. Возврат AgentExecution                                     │
│      - task: исходная задача                                    │
│      - steps: список всех шагов                                 │
│      - success: статус выполнения                               │
│      - final_result: финальный ответ                            │
│      - total_tokens: суммарное использование токенов            │
│      - execution_time: общее время выполнения                   │
└─────────────────────────────────────────────────────────────────┘
```

### Последовательность промтов и данных

На каждом шаге N контекст для LLM включает:

1. **System Message (постоянный):**
   ```
   TRAE_AGENT_SYSTEM_PROMPT
   ```

2. **Initial User Message (постоянный):**
   ```
   [Project root path]: /path/to/project
   [Problem statement]: {issue_text}
   ```

3. **История предыдущих шагов:**
   - Assistant Message: Ответ LLM с предыдущего шага
   - User Message: Результаты выполнения инструментов

4. **Tool Descriptions (в виде function definitions):**
   - Каждый инструмент предоставляет свой description как промт

### Пример потока данных

**Шаг 1:**
```
Input → LLM:
  - System: TRAE_AGENT_SYSTEM_PROMPT
  - User: [Project path + Issue]

Output ← LLM:
  - content: "I'll start by examining the codebase..."
  - tool_calls: [
      {name: "bash", arguments: {command: "find . -name '*.py'"}}
    ]
```

**Шаг 2:**
```
Input → Tool (bash):
  - command: "find . -name '*.py'"

Output ← Tool:
  - result: "file1.py\nfile2.py\n..."
  - success: true

Input → LLM:
  - Previous messages...
  - User: {tool_result}

Output ← LLM:
  - content: "Based on the files, I'll examine file1.py"
  - tool_calls: [
      {name: "str_replace_based_edit_tool",
       arguments: {command: "view", path: "/abs/path/file1.py"}}
    ]
```

Этот цикл повторяется до вызова `task_done` или достижения `max_steps`.

### Условия завершения

1. **Успешное завершение:**
   - LLM вызывает инструмент `task_done`
   - `execution.success = True`
   - `execution.agent_state = AgentState.COMPLETED`

2. **Превышение лимита шагов:**
   - `step_number > max_steps`
   - `execution.success = False`
   - `execution.final_result = "Task execution exceeded maximum steps..."`
   - `execution.agent_state = AgentState.ERROR`

3. **Ошибка выполнения:**
   - Исключение во время выполнения
   - `execution.agent_state = AgentState.ERROR`
   - Детали ошибки в `step.error`

---

## 2. Пайплайн выполнения инструментов

**Описание:** Детальный пайплайн того, как происходит выполнение инструментов (tools) после того, как LLM решает их вызвать.

**Входные данные:**
- `tool_calls`: Список ToolCall объектов от LLM
  - `name`: Имя инструмента
  - `arguments`: Словарь аргументов
  - `call_id`: Уникальный идентификатор вызова

**Выходные данные:**
- `List[LLMMessage]`: Сообщения с результатами выполнения инструментов

### ASCII диаграмма пайплайна:

```
┌─────────────────────────────────────────────────────────────────┐
│         LLM Response содержит tool_calls                        │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  1. ToolExecutor получает tool_calls                            │
└───────────────────────┬─────────────────────────────────────────┘
                        │
        ┌───────────────┴───────────────┐
        │  Для каждого tool_call:       │
        └───────────────┬───────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  2. Поиск инструмента по имени                                  │
│     tool = find_tool_by_name(tool_call.name)                    │
│                                                                 │
│     Если не найден:                                             │
│       → ToolResult(success=False,                               │
│                    error="Tool not found")                      │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  3. Валидация аргументов                                        │
│     - Проверка обязательных параметров (required=True)          │
│     - Проверка типов данных                                     │
│     - Проверка enum значений                                    │
│     - Проверка минимальных/максимальных значений                │
│                                                                 │
│     Если валидация не прошла:                                   │
│       → ToolResult(success=False,                               │
│                    error="Invalid arguments: ...")              │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  4. Специальная обработка для разных инструментов               │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  Sequential Thinking Tool                                │  │
│  │  - Валидация ThoughtData                                 │  │
│  │  - Добавление в thought_history                          │  │
│  │  - Обработка ветвления (branching)                       │  │
│  │  - Форматирование вывода                                 │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  Text Editor Tool (str_replace_based_edit_tool)          │  │
│  │  - view: cat -n или find для директорий                  │  │
│  │  - create: Создание файла (только если не существует)    │  │
│  │  - str_replace: Замена old_str → new_str                 │  │
│  │    • Проверка уникальности old_str                       │  │
│  │    • Точное совпадение (включая пробелы)                 │  │
│  │  - insert: Вставка на insert_line                        │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  Bash Tool                                               │  │
│  │  - Создание/переиспользование bash сессии                │  │
│  │  - Выполнение команды с timeout (120s по умолчанию)      │  │
│  │  - Захват stdout и stderr                                │  │
│  │  - Получение exit code                                   │  │
│  │  - restart=True: Перезапуск сессии                       │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  JSON Edit Tool                                          │  │
│  │  - view: Просмотр JSON с JSONPath фильтрацией            │  │
│  │  - set: Обновление значений по JSONPath                  │  │
│  │  - add: Добавление ключей/элементов                      │  │
│  │  - remove: Удаление по JSONPath                          │  │
│  │  - Валидация JSON и JSONPath выражений                   │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  CKG Tool (Code Knowledge Graph)                         │  │
│  │  - Проверка/создание CKG для кодовой базы               │  │
│  │  - search_function: Поиск функций                        │  │
│  │  - search_class: Поиск классов                           │  │
│  │  - search_class_method: Поиск методов классов            │  │
│  │  - Возврат тела + метаданных (файл, строки)             │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  Task Done Tool                                          │  │
│  │  - Простое подтверждение завершения                      │  │
│  │  - Триггер для изменения agent_state на COMPLETED        │  │
│  └──────────────────────────────────────────────────────────┘  │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  5. Выполнение tool.execute(arguments)                          │
│     result = await tool.execute(arguments)                      │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  6. Обработка результата                                        │
│                                                                 │
│     Если успех (ToolExecResult.error is None):                  │
│       ToolResult(                                               │
│         call_id=tool_call.call_id,                              │
│         name=tool_name,                                         │
│         success=True,                                           │
│         result=tool_exec_result.output                          │
│       )                                                         │
│                                                                 │
│     Если ошибка (ToolExecResult.error is not None):             │
│       ToolResult(                                               │
│         call_id=tool_call.call_id,                              │
│         name=tool_name,                                         │
│         success=False,                                          │
│         error=tool_exec_result.error                            │
│       )                                                         │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  7. Создание LLMMessage с результатом                           │
│     LLMMessage(                                                 │
│       role="user",                                              │
│       content=tool_result.result or tool_result.error,          │
│       tool_result=tool_result                                   │
│     )                                                           │
└───────────────────────┬─────────────────────────────────────────┘
                        │
        Все tool_calls обработаны?
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  8. Возврат списка LLMMessage                                   │
│     Будут добавлены в контекст для следующего LLM вызова        │
└─────────────────────────────────────────────────────────────────┘
```

### Особенности выполнения инструментов

1. **Параллельное выполнение:**
   - Если LLM возвращает несколько tool_calls, они выполняются последовательно
   - Каждый tool_call получает отдельный ToolResult

2. **Обработка ошибок:**
   - Ошибки валидации возвращаются как ToolResult с success=False
   - Исключения во время выполнения перехватываются и возвращаются как errors
   - LLM получает информацию об ошибке и может попробовать снова

3. **Персистентность состояния:**
   - Bash Tool: Сохраняет сессию между вызовами
   - CKG Tool: Кэширует построенный граф знаний
   - Edit Tool: Работает с реальной файловой системой

4. **Docker режим:**
   - Инструменты bash, str_replace_based_edit_tool, json_edit_tool могут выполняться в Docker
   - DockerToolExecutor транслирует пути между хостом и контейнером
   - Выполнение через CLI внутри контейнера

---

## 3. Пайплайн анализа траектории (LakeView)

**Описание:** LakeView - система для пост-обработки траектории агента с целью создания читаемых отчетов. Она анализирует каждый шаг, извлекает семантическое описание действий и присваивает категории.

**Входные данные:**
- `AgentStep`: Объект шага с LLM ответом и вызовами инструментов
- `steps`: История всех предыдущих шагов

**Выходные данные:**
- `LakeViewStep`: Объект с описанием и тегами
  - `desc_task`: Краткое описание задачи (≤10 слов)
  - `desc_details`: Детальное описание (≤30 слов)
  - `tags_emoji`: Теги с эмодзи для визуализации

### ASCII диаграмма пайплайна:

```
┌─────────────────────────────────────────────────────────────────┐
│  После завершения каждого шага агента (AgentStep)               │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  1. Проверка настроек LakeView                                  │
│     if config.enable_lakeview: продолжить                       │
│     else: пропустить анализ                                     │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  2. Подготовка данных шага                                      │
│     step_str = format_agent_step(agent_step)                    │
│                                                                 │
│     Формат:                                                     │
│     - LLM content: текстовый ответ агента                       │
│     - Tool calls: список вызовов с аргументами                  │
│       [`tool_name`] `{arguments}`                               │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
        ┌───────────────┴───────────────┐
        │  Параллельный анализ          │
        └───────┬───────────────┬───────┘
                │               │
                ▼               ▼
┌───────────────────────┐  ┌─────────────────────────────────┐
│  3a. EXTRACTOR        │  │  3b. TAGGER                     │
│  Извлечение описания  │  │  Присвоение тегов               │
└───────┬───────────────┘  └───────┬─────────────────────────┘
        │                          │
        ▼                          ▼
┌───────────────────────────────────────────────────────────────┐
│  EXTRACTOR PIPELINE                                           │
│                                                               │
│  Input → LLM (temperature=0.1):                               │
│    User: "The following is an excerpt..."                    │
│          <previous_step>{prev_step}</previous_step>           │
│          <this_step>{this_step}</this_step>                   │
│    Assistant: "I understand."                                │
│    User: {EXTRACTOR_PROMPT}                                  │
│    Assistant: "Sure. Here is the task: <task>The agent"      │
│                                                               │
│  Промт EXTRACTOR_PROMPT содержит:                             │
│    - Инструкцию определить задачу агента                      │
│    - Формат вывода: <task>...</task><details>...</details>    │
│    - Примеры корректного извлечения                           │
│                                                               │
│  Output ← LLM:                                                │
│    "<task>The agent is writing a test script</task>          │
│     <details>Writing test_bug.py to reproduce...</details>"  │
│                                                               │
│  Парсинг результата:                                          │
│    - Извлечение текста между тегами                           │
│    - Retry до 10 раз если формат неверный                     │
│    - Возврат (desc_task, desc_details)                        │
└───────────────────────┬───────────────────────────────────────┘
                        │
                        ▼
┌───────────────────────────────────────────────────────────────┐
│  TAGGER PIPELINE                                              │
│                                                               │
│  Input → LLM (temperature=0.1):                               │
│    User: "Below is the trajectory..."                        │
│          <step id="1">{step_1}</step>                         │
│          <step id="2">{step_2}</step>                         │
│          ...                                                  │
│          <current_step>{current_step}</current_step>          │
│    Assistant: "I understand."                                │
│    User: {TAGGER_PROMPT}                                     │
│    Assistant: "Sure. The tags are: <tags>"                   │
│                                                               │
│  Промт TAGGER_PROMPT содержит:                                │
│    - Список доступных тегов с описаниями:                     │
│      • WRITE_TEST: написание теста                            │
│      • VERIFY_TEST: запуск теста                              │
│      • EXAMINE_CODE: просмотр кода                            │
│      • WRITE_FIX: исправление кода                            │
│      • VERIFY_FIX: проверка исправления                       │
│      • REPORT: отчет пользователю                             │
│      • THINK: размышление без действий                        │
│      • OUTLIER: нестандартное действие                        │
│    - Примеры присвоения тегов                                 │
│    - Инструкция выбрать все подходящие теги                   │
│                                                               │
│  Output ← LLM:                                                │
│    "<tags>EXAMINE_CODE</tags>"                                │
│    или                                                        │
│    "<tags>WRITE_TEST,VERIFY_TEST</tags>"                      │
│                                                               │
│  Парсинг результата:                                          │
│    - Извлечение тегов через regex                             │
│    - Валидация против KNOWN_TAGS                              │
│    - Retry до 10 раз если теги некорректны                    │
│    - Возврат списка тегов: ["EXAMINE_CODE"]                   │
└───────────────────────┬───────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  4. Объединение результатов                                     │
│     LakeViewStep(                                               │
│       desc_task="The agent is examining source code",           │
│       desc_details="Searching for 'function_name' in...",       │
│       tags_emoji="👁️ EXAMINE_CODE"                             │
│     )                                                           │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  5. Добавление в историю                                        │
│     self.steps.append(this_step_str)                            │
│     - Используется для контекста в следующих вызовах TAGGER     │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  6. Визуализация в CLI Console                                  │
│     Отображение шага с тегами и описанием                       │
│     Например: "👁️ The agent is examining source code"          │
└─────────────────────────────────────────────────────────────────┘
```

### Поток данных через LakeView

**Шаг 1 агента:**
```
AgentStep:
  llm_response.content: "Let me examine the code..."
  tool_calls: [bash("find . -name '*.py'")]

↓ LakeView Analysis ↓

EXTRACTOR получает:
  previous_step: "(none)"
  this_step: "Let me examine... [bash] find . -name '*.py'"

EXTRACTOR возвращает:
  task: "The agent is searching for Python files"
  details: "Using find command to locate all .py files in repo"

TAGGER получает:
  trajectory: [step 1 formatted]
  current_step: "Let me examine... [bash] find . -name '*.py'"

TAGGER возвращает:
  tags: ["EXAMINE_CODE"]

↓ Результат ↓

LakeViewStep:
  desc_task: "The agent is searching for Python files"
  desc_details: "Using find command to locate all .py files in repo"
  tags_emoji: "👁️ EXAMINE_CODE"
```

### Оптимизации и ограничения

1. **Ограничение по длине траектории:**
   - Если `len(steps_fmt) > 300,000` символов → пропуск тегирования
   - Экстрактор работает только с prev_step и this_step (всегда выполняется)

2. **Температура LLM:**
   - Используется `temperature=0.1` для детерминированности
   - Помогает получать стабильные результаты

3. **Retry логика:**
   - До 10 попыток для каждого промта
   - Гарантирует корректный формат вывода

4. **Кэширование:**
   - История шагов накапливается для контекста
   - Не требует повторного анализа предыдущих шагов

---

## 4. Пайплайн выбора патчей (Patch Selector)

**Описание:** Специализированный пайплайн для оценки и выбора лучшего патча из нескольких кандидатов. Используется в системе evaluation для автоматического выбора корректных решений.

**Входные данные:**
- `candidate_list`: Список CandidatePatch объектов
  - `id`: Идентификатор патча
  - `patch`: Текст патча (git diff)
  - `is_success_regression`: Прошел ли регрессионные тесты
  - `is_success_patch`: Корректный ли патч по другим метрикам
- `project_path`: Путь к проекту
- `issue_description`: Описание GitHub issue

**Выходные данные:**
- `final_id`: ID выбранного патча
- `final_patch`: Текст выбранного патча

### ASCII диаграмма пайплайна:

```
┌─────────────────────────────────────────────────────────────────┐
│  ИНИЦИАЛИЗАЦИЯ SELECTOR AGENT                                   │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  1. Создание sandbox сессии                                     │
│     sandbox = Sandbox(project_path)                             │
│     sandbox_session = sandbox.get_session()                     │
│     sandbox_session.execute("git reset --hard HEAD")            │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  2. Подготовка системного промта                                │
│     system_prompt = build_system_prompt(len(candidate_list))    │
│                                                                 │
│     Промт включает:                                             │
│     - Роль: expert code evaluator                               │
│     - Количество кандидатов: N patches                          │
│     - 4-шаговый процесс работы                                  │
│     - Формат финального отчета                                  │
│     - Ограничения: нельзя избегать выбора, создавать новые      │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  3. Формирование user_prompt                                    │
│     user_prompt = f"""                                          │
│     [Codebase path]: {project_path}                             │
│                                                                 │
│     [Github issue description]:                                 │
│     ```{issue_description}```                                   │
│                                                                 │
│     [Candidate Patches]:                                        │
│     Patch-1:                                                    │
│     ```{patch_1}```                                             │
│     Patch-2:                                                    │
│     ```{patch_2}```                                             │
│     ...                                                         │
│     """                                                         │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  4. Инициализация инструментов                                  │
│     tools = [                                                   │
│       bash_tool,                                                │
│       str_replace_based_edit_tool                               │
│     ]                                                           │
│     - Оба инструмента выполняются в sandbox                     │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
        ┌───────────────┴───────────────┐
        │   ЦИКЛ ВЫПОЛНЕНИЯ ШАГОВ      │
        │   (до max_turn или selection) │
        └───────────────┬───────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  ШАГ N (повторяется до max_turn)                                │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  5. Вызов LLM                                            │  │
│  │     response = llm_client.chat(messages, config, tools) │  │
│  │                                                          │  │
│  │     Контекст:                                            │  │
│  │     - System: build_system_prompt(N)                     │  │
│  │     - User: [Codebase + Issue + Candidate Patches]      │  │
│  │     - History: Предыдущие действия и результаты          │  │
│  └────────────────────────┬─────────────────────────────────┘  │
│                           ▼                                     │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  6. Анализ ответа LLM                                    │  │
│  │                                                          │  │
│  │  Поиск паттерна завершения:                              │  │
│  │  regex: "Status:\s*(success|succeed|successfully)"       │  │
│  └────────────────────────┬─────────────────────────────────┘  │
│                           ▼                                     │
│            ┌──────────────┴──────────────┐                      │
│            │  Найден паттерн завершения? │                      │
│            └──────┬──────────────┬───────┘                      │
│                   │              │                              │
│                 ДА│              │НЕТ                            │
│                   ▼              ▼                              │
│  ┌────────────────────┐  ┌────────────────────────────────┐    │
│  │  7a. Извлечение    │  │  7b. Выполнение инструментов   │    │
│  │  выбранного патча  │  │                                │    │
│  │                    │  │  Для каждого tool_call:        │    │
│  │  Поиск "Result:"   │  │                                │    │
│  │  regex: "Result:   │  │  ┌──────────────────────────┐  │    │
│  │  \s*(.+?)\s*       │  │  │  bash или edit tool      │  │    │
│  │  Analysis:"        │  │  │  - Формирование команды  │  │    │
│  │                    │  │  │  - Выполнение в sandbox  │  │    │
│  │  Парсинг:          │  │  │  - Захват вывода         │  │    │
│  │  "Result: Patch-3" │  │  └────────┬─────────────────┘  │    │
│  │  → id = 3          │  │           ▼                    │    │
│  │  → final_patch =   │  │  ┌──────────────────────────┐  │    │
│  │     candidate[2]   │  │  │  Результат в sandbox     │  │    │
│  │                    │  │  │  sandbox.execute(        │  │    │
│  │  ВЫХОД ИЗ ЦИКЛА   │  │  │    "cat log.out")        │  │    │
│  └────────────────────┘  │  └────────┬─────────────────┘  │    │
│                          │           ▼                    │    │
│                          │  ┌──────────────────────────┐  │    │
│                          │  │  LLM Message с          │  │    │
│                          │  │  результатом             │  │    │
│                          │  │  role="user"             │  │    │
│                          │  │  content=tool_output     │  │    │
│                          │  └──────────────────────────┘  │    │
│                          └───────────┼────────────────────┘    │
│                                      │                          │
└──────────────────────────────────────┼──────────────────────────┘
                                       │
        Переход к следующему шагу (N+1)
                                       │
                                       ▼
┌─────────────────────────────────────────────────────────────────┐
│  8. Финализация выполнения                                      │
│     - Запись траектории                                         │
│     - git reset --hard HEAD в sandbox                           │
│     - Закрытие sandbox сессии                                   │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  9. Возврат результата                                          │
│     return (final_id, final_patch)                              │
└─────────────────────────────────────────────────────────────────┘
```

### Последовательность промтов и данных

**Инициализация:**
```
System Message:
  build_system_prompt(3)  # Для 3 кандидатов

User Message:
  [Codebase path]: /workspace/project

  [Github issue]:
  ```
  Bug in authentication: users cannot login...
  ```

  [Candidate Patches]:
  Patch-1:
  ```diff
  - if password == stored_hash:
  + if bcrypt.check(password, stored_hash):
  ```

  Patch-2:
  ```diff
  - return user.is_authenticated
  + return user.is_authenticated()
  ```

  Patch-3:
  ```diff
  - if user.check_password(password):
  + if user and user.check_password(password):
  ```
```

**Шаг 1 - Исследование:**
```
LLM Response:
  content: "Let me examine the authentication code to understand..."
  tool_calls: [
    {
      name: "str_replace_based_edit_tool",
      arguments: {
        command: "view",
        path: "/workspace/project/auth.py"
      }
    }
  ]

Tool Result:
  success: True
  result: "Content of auth.py..."

→ Добавляется в messages для следующего шага
```

**Шаг 2 - Тестирование:**
```
LLM Response:
  content: "I'll test each patch..."
  tool_calls: [
    {
      name: "bash",
      arguments: {
        command: "pytest tests/test_auth.py"
      }
    }
  ]

Tool Result:
  success: True
  result: "5 passed, 2 failed..."

→ Добавляется в messages
```

**Шаг 3 - Выбор:**
```
LLM Response:
  content: """Based on my analysis...

  ### Status: succeed
  ### Result: Patch-3
  ### Analysis: Patch-3 correctly handles the case when user is None
  before attempting to check the password, preventing NullPointerError.
  """

Парсинг:
  - Найден "Status: succeed"
  - Извлечен "Result: Patch-3"
  - final_id = candidate_list[2].id
  - final_patch = candidate_list[2].patch

→ ЗАВЕРШЕНИЕ
```

### Особенности Patch Selector Pipeline

1. **Sandbox изоляция:**
   - Все операции выполняются в изолированной среде
   - git reset между тестированием разных патчей
   - Предотвращает побочные эффекты

2. **Специальная обработка инструментов:**
   - Bash и Edit tools выполняются через CLI в sandbox
   - Преобразование путей между sandbox и реальной ФС
   - Вывод через временные файлы (log.out)

3. **Обязательный выбор:**
   - Промт требует выбрать один из патчей
   - Если формат вывода некорректен → выбирается Patch-1 по умолчанию
   - Гарантирует возврат результата

4. **Timeout обработка:**
   - Если инструмент висит > timeout → перезапуск sandbox
   - Создание новой сессии для продолжения

5. **Траектория:**
   - Все взаимодействия записываются в trajectory файл
   - Финальный патч добавляется в конце записи
   - Позволяет анализировать процесс принятия решений

### Формат финального отчета

Selector agent должен вернуть ответ в формате:
```
### Status: succeed
### Result: Patch-{N}
### Analysis: {Объяснение выбора}
```

Где:
- `Status` может быть: succeed, success, successfully, successful
- `Result` должен содержать номер патча (Patch-1, Patch-2, и т.д.)
- `Analysis` объясняет почему этот патч корректен

---

## Заключение

Все пайплайны TRAE Agent спроектированы для создания надежного и наблюдаемого процесса решения задач:

1. **Основной пайплайн (Main Solving):** Итеративный цикл LLM → Tools → LLM с полным контекстом и историей

2. **Пайплайн инструментов (Tool Execution):** Валидация, выполнение и обработка ошибок с персистентным состоянием

3. **LakeView пайплайн (Trajectory Analysis):** Пост-обработка для создания читаемых отчетов с семантическими тегами

4. **Patch Selector пайплайн:** Специализированный агент для выбора лучших решений из множества кандидатов

Каждый пайплайн использует специфические промты и обрабатывает данные в строго определенном порядке, обеспечивая детерминированность и наблюдаемость процесса.

