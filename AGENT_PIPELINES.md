# Документация пайплайнов TRAE Agent

Этот документ описывает все возможные схемы работы агента (pipelines) - последовательности вызовов промтов, инструментов и обработки данных.

## Содержание

1. [Основной пайплайн решения задач](#1-основной-пайплайн-решения-задач)
2. [Пайплайн выполнения инструментов](#2-пайплайн-выполнения-инструментов)
3. [Пайплайн анализа траектории (LakeView)](#3-пайплайн-анализа-траектории-lakeview)
4. [Пайплайн выбора патчей (Patch Selector)](#4-пайплайн-выбора-патчей-patch-selector)

---

## 1. Основной пайплайн решения задач

**Описание:** Это главный пайплайн работы TRAE Agent для решения GitHub issues. Он включает инициализацию, выполнение шагов с использованием LLM и инструментов, и финализацию результата.

**Входные данные:**
- `task`: Описание задачи
- `project_path`: Путь к проекту
- `issue`: Текст GitHub issue
- `base_commit` (опционально): Базовый коммит для сравнения
- `patch_path` (опционально): Путь для сохранения патча

**Выходные данные:**
- `AgentExecution`: Объект с результатами выполнения
  - `success`: Успешность выполнения
  - `steps`: Список всех шагов
  - `final_result`: Финальный результат
  - `total_tokens`: Использованные токены
  - `execution_time`: Время выполнения

### ASCII диаграмма пайплайна:

```
┌─────────────────────────────────────────────────────────────────┐
│                    ИНИЦИАЛИЗАЦИЯ АГЕНТА                         │
└───────────────────────────┬─────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│  1. Создание начальных сообщений (initial_messages)             │
│     - System Message: TRAE_AGENT_SYSTEM_PROMPT                  │
│     - User Message: [Project root path] + [Problem statement]   │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  2. Инициализация инструментов                                  │
│     - str_replace_based_edit_tool                               │
│     - bash                                                      │
│     - sequentialthinking                                        │
│     - json_edit_tool                                            │
│     - task_done                                                 │
│     - ckg (опционально)                                         │
│     - MCP tools (если настроены)                                │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  3. Начало записи траектории                                    │
│     TrajectoryRecorder.start_recording()                        │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
        ┌───────────────┴───────────────┐
        │   ЦИКЛ ВЫПОЛНЕНИЯ ШАГОВ      │
        │   (до max_steps или success)  │
        └───────────────┬───────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  ШАГ N (повторяется до max_steps)                               │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  4. Состояние: THINKING                                  │  │
│  │     - Обновление CLI консоли                             │  │
│  └────────────────────────┬─────────────────────────────────┘  │
│                           ▼                                     │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  5. Вызов LLM                                            │  │
│  │     LLMClient.chat(messages, model_config, tools)        │  │
│  │                                                          │  │
│  │     Промты в контексте:                                  │  │
│  │     - System: TRAE_AGENT_SYSTEM_PROMPT                   │  │
│  │     - User: Issue description + project path             │  │
│  │     - History: Все предыдущие сообщения и результаты     │  │
│  │     - Tools: Описания всех доступных инструментов        │  │
│  └────────────────────────┬─────────────────────────────────┘  │
│                           ▼                                     │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  6. Получение LLM Response                               │  │
│  │     - content: Текстовый ответ агента                    │  │
│  │     - tool_calls: Список вызовов инструментов (если есть)│  │
│  │     - usage: Информация о токенах                        │  │
│  └────────────────────────┬─────────────────────────────────┘  │
│                           ▼                                     │
│            ┌──────────────┴──────────────┐                      │
│            │  Проверка завершения        │                      │
│            └──────┬──────────────┬───────┘                      │
│                   │              │                              │
│          task_done вызван?    tool_calls?                       │
│                   │              │                              │
│                   ▼              ▼                              │
│  ┌────────────────────┐  ┌────────────────────────────────┐    │
│  │  7a. Завершение    │  │  7b. Состояние: CALLING_TOOL   │    │
│  │  - success = True  │  │     Для каждого tool_call:     │    │
│  │  - final_result    │  │                                │    │
│  │  - ВЫХОД ИЗ ЦИКЛА │  │  ┌──────────────────────────┐  │    │
│  └────────────────────┘  │  │  Tool Executor           │  │    │
│                          │  │  - Парсинг аргументов    │  │    │
│                          │  │  - Валидация параметров  │  │    │
│                          │  │  - Выполнение tool.execute│ │    │
│                          │  └────────┬─────────────────┘  │    │
│                          │           ▼                    │    │
│                          │  ┌──────────────────────────┐  │    │
│                          │  │  Tool Result             │  │    │
│                          │  │  - success: bool         │  │    │
│                          │  │  - result: string        │  │    │
│                          │  │  - error: string|None    │  │    │
│                          │  └────────┬─────────────────┘  │    │
│                          └───────────┼────────────────────┘    │
│                                      ▼                          │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  8. Создание User Message с результатами                 │  │
│  │     messages.append(LLMMessage(                          │  │
│  │         role="user",                                     │  │
│  │         content=tool_result.result,                      │  │
│  │         tool_result=tool_result                          │  │
│  │     ))                                                   │  │
│  └────────────────────────┬─────────────────────────────────┘  │
│                           ▼                                     │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  9. Рефлексия (опционально)                              │  │
│  │     reflect_on_result(tool_results)                      │  │
│  │     - Анализ ошибок выполнения инструментов              │  │
│  └────────────────────────┬─────────────────────────────────┘  │
│                           ▼                                     │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  10. Состояние: COMPLETED                                │  │
│  │      - Запись шага в траекторию                          │  │
│  │      - Обновление CLI консоли                            │  │
│  │      - Добавление шага в execution.steps                 │  │
│  └────────────────────────┬─────────────────────────────────┘  │
│                           │                                     │
└───────────────────────────┼─────────────────────────────────────┘
                            │
        Переход к следующему шагу (N+1)
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│  11. Финализация выполнения                                     │
│      - TrajectoryRecorder.finalize_recording()                  │
│      - Сохранение git diff в patch_path (если указан)           │
│      - Закрытие всех инструментов (bash sessions и т.д.)        │
│      - Cleanup MCP clients                                      │
│      - Остановка Docker (если использовался)                    │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  12. Возврат AgentExecution                                     │
│      - task: исходная задача                                    │
│      - steps: список всех шагов                                 │
│      - success: статус выполнения                               │
│      - final_result: финальный ответ                            │
│      - total_tokens: суммарное использование токенов            │
│      - execution_time: общее время выполнения                   │
└─────────────────────────────────────────────────────────────────┘
```

### Последовательность промтов и данных

На каждом шаге N контекст для LLM включает:

1. **System Message (постоянный):**
   ```
   TRAE_AGENT_SYSTEM_PROMPT
   ```

2. **Initial User Message (постоянный):**
   ```
   [Project root path]: /path/to/project
   [Problem statement]: {issue_text}
   ```

3. **История предыдущих шагов:**
   - Assistant Message: Ответ LLM с предыдущего шага
   - User Message: Результаты выполнения инструментов

4. **Tool Descriptions (в виде function definitions):**
   - Каждый инструмент предоставляет свой description как промт

### Пример потока данных

**Шаг 1:**
```
Input → LLM:
  - System: TRAE_AGENT_SYSTEM_PROMPT
  - User: [Project path + Issue]

Output ← LLM:
  - content: "I'll start by examining the codebase..."
  - tool_calls: [
      {name: "bash", arguments: {command: "find . -name '*.py'"}}
    ]
```

**Шаг 2:**
```
Input → Tool (bash):
  - command: "find . -name '*.py'"

Output ← Tool:
  - result: "file1.py\nfile2.py\n..."
  - success: true

Input → LLM:
  - Previous messages...
  - User: {tool_result}

Output ← LLM:
  - content: "Based on the files, I'll examine file1.py"
  - tool_calls: [
      {name: "str_replace_based_edit_tool",
       arguments: {command: "view", path: "/abs/path/file1.py"}}
    ]
```

Этот цикл повторяется до вызова `task_done` или достижения `max_steps`.

### Условия завершения

1. **Успешное завершение:**
   - LLM вызывает инструмент `task_done`
   - `execution.success = True`
   - `execution.agent_state = AgentState.COMPLETED`

2. **Превышение лимита шагов:**
   - `step_number > max_steps`
   - `execution.success = False`
   - `execution.final_result = "Task execution exceeded maximum steps..."`
   - `execution.agent_state = AgentState.ERROR`

3. **Ошибка выполнения:**
   - Исключение во время выполнения
   - `execution.agent_state = AgentState.ERROR`
   - Детали ошибки в `step.error`

---

## 2. Пайплайн выполнения инструментов

**Описание:** Детальный пайплайн того, как происходит выполнение инструментов (tools) после того, как LLM решает их вызвать.

**Входные данные:**
- `tool_calls`: Список ToolCall объектов от LLM
  - `name`: Имя инструмента
  - `arguments`: Словарь аргументов
  - `call_id`: Уникальный идентификатор вызова

**Выходные данные:**
- `List[LLMMessage]`: Сообщения с результатами выполнения инструментов

### ASCII диаграмма пайплайна:

```
┌─────────────────────────────────────────────────────────────────┐
│         LLM Response содержит tool_calls                        │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  1. ToolExecutor получает tool_calls                            │
└───────────────────────┬─────────────────────────────────────────┘
                        │
        ┌───────────────┴───────────────┐
        │  Для каждого tool_call:       │
        └───────────────┬───────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  2. Поиск инструмента по имени                                  │
│     tool = find_tool_by_name(tool_call.name)                    │
│                                                                 │
│     Если не найден:                                             │
│       → ToolResult(success=False,                               │
│                    error="Tool not found")                      │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  3. Валидация аргументов                                        │
│     - Проверка обязательных параметров (required=True)          │
│     - Проверка типов данных                                     │
│     - Проверка enum значений                                    │
│     - Проверка минимальных/максимальных значений                │
│                                                                 │
│     Если валидация не прошла:                                   │
│       → ToolResult(success=False,                               │
│                    error="Invalid arguments: ...")              │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  4. Специальная обработка для разных инструментов               │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  Sequential Thinking Tool                                │  │
│  │  - Валидация ThoughtData                                 │  │
│  │  - Добавление в thought_history                          │  │
│  │  - Обработка ветвления (branching)                       │  │
│  │  - Форматирование вывода                                 │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  Text Editor Tool (str_replace_based_edit_tool)          │  │
│  │  - view: cat -n или find для директорий                  │  │
│  │  - create: Создание файла (только если не существует)    │  │
│  │  - str_replace: Замена old_str → new_str                 │  │
│  │    • Проверка уникальности old_str                       │  │
│  │    • Точное совпадение (включая пробелы)                 │  │
│  │  - insert: Вставка на insert_line                        │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  Bash Tool                                               │  │
│  │  - Создание/переиспользование bash сессии                │  │
│  │  - Выполнение команды с timeout (120s по умолчанию)      │  │
│  │  - Захват stdout и stderr                                │  │
│  │  - Получение exit code                                   │  │
│  │  - restart=True: Перезапуск сессии                       │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  JSON Edit Tool                                          │  │
│  │  - view: Просмотр JSON с JSONPath фильтрацией            │  │
│  │  - set: Обновление значений по JSONPath                  │  │
│  │  - add: Добавление ключей/элементов                      │  │
│  │  - remove: Удаление по JSONPath                          │  │
│  │  - Валидация JSON и JSONPath выражений                   │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  CKG Tool (Code Knowledge Graph)                         │  │
│  │  - Проверка/создание CKG для кодовой базы               │  │
│  │  - search_function: Поиск функций                        │  │
│  │  - search_class: Поиск классов                           │  │
│  │  - search_class_method: Поиск методов классов            │  │
│  │  - Возврат тела + метаданных (файл, строки)             │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  Task Done Tool                                          │  │
│  │  - Простое подтверждение завершения                      │  │
│  │  - Триггер для изменения agent_state на COMPLETED        │  │
│  └──────────────────────────────────────────────────────────┘  │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  5. Выполнение tool.execute(arguments)                          │
│     result = await tool.execute(arguments)                      │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  6. Обработка результата                                        │
│                                                                 │
│     Если успех (ToolExecResult.error is None):                  │
│       ToolResult(                                               │
│         call_id=tool_call.call_id,                              │
│         name=tool_name,                                         │
│         success=True,                                           │
│         result=tool_exec_result.output                          │
│       )                                                         │
│                                                                 │
│     Если ошибка (ToolExecResult.error is not None):             │
│       ToolResult(                                               │
│         call_id=tool_call.call_id,                              │
│         name=tool_name,                                         │
│         success=False,                                          │
│         error=tool_exec_result.error                            │
│       )                                                         │
└───────────────────────┬─────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  7. Создание LLMMessage с результатом                           │
│     LLMMessage(                                                 │
│       role="user",                                              │
│       content=tool_result.result or tool_result.error,          │
│       tool_result=tool_result                                   │
│     )                                                           │
└───────────────────────┬─────────────────────────────────────────┘
                        │
        Все tool_calls обработаны?
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│  8. Возврат списка LLMMessage                                   │
│     Будут добавлены в контекст для следующего LLM вызова        │
└─────────────────────────────────────────────────────────────────┘
```

### Особенности выполнения инструментов

1. **Параллельное выполнение:**
   - Если LLM возвращает несколько tool_calls, они выполняются последовательно
   - Каждый tool_call получает отдельный ToolResult

2. **Обработка ошибок:**
   - Ошибки валидации возвращаются как ToolResult с success=False
   - Исключения во время выполнения перехватываются и возвращаются как errors
   - LLM получает информацию об ошибке и может попробовать снова

3. **Персистентность состояния:**
   - Bash Tool: Сохраняет сессию между вызовами
   - CKG Tool: Кэширует построенный граф знаний
   - Edit Tool: Работает с реальной файловой системой

4. **Docker режим:**
   - Инструменты bash, str_replace_based_edit_tool, json_edit_tool могут выполняться в Docker
   - DockerToolExecutor транслирует пути между хостом и контейнером
   - Выполнение через CLI внутри контейнера

